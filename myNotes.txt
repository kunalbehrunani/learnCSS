Types of CSS -
1. Inline Styling
2. Internal Style sheet
3. External Style sheet

Rule Set design - 

selector {
  key1: value1;       //properties
  key2: value2;
 }                    //declaration block


Selectors - 

1. Type selectors
2. universal selectors {*}
3. class selectors {.} 
4. id selectors {#}
5. Attribute selectors {[]}
6. pseudo-class selectors {:}
7. multiple selectors {,}

Specificity of selectors : type < class < id {order of overriding styles} Best practice - use least specificity. 

Chaining -> Classifying elements based on both type & class simultaneously. h1.className{} etc. h1: type, className: class type.

Chaining increases specificity. 

Descendant Combinators -> to target descendant/child elements of a given class. eg. Parent-selector chile-selector{} or .className descendantElementName {}

Descendant Combinators increases specificity.

Chaining Vs DC -> Chaining will consider both. Eg. h1.className{} => This would apply the styling to those elements which are h1 AND has class="className". While, DC would just apply styling to descendants/child elements. Ege. h1 p {} -> This would apply styling to only those p elements that are child to h1 elements. 




Lesson #2 - Visual Rules

font-family - Use Web Safe CSS Fonts. Compatible with most browsers. Others should be downloaded to use. may react differently on diff browsers.
font-size
font-weight
text-align - Alignment done with reference to parent html element
color - Foreground color
background-color
opacity - Range[0,1]
"!important" - eg. p{color:blue !important;} // override this style irrespective of specificity.


Lesson #3 - The Box Model

Every html element resides inside a box. 
Paramters of that box - content area (width & height), margins, border, padding.

Major keywords - width, height, padding, border, margin, overflow

Overflow => 3 values ie. visible, hidden, scroll {for spill over content w.r.t the parent box dimensions}

Content area - height & width;

border - syntax: border: size style color;
  default: medium none color {color of the element}
  size - in pixels, or keywords - thin, medium, thick
  style - solid, dotted, none etc.
  color - as usual.
border-radius: size;
if(height===width) && border-radius:50% => perfect circle outline

Padding -> space between the content & it's border.Mostly used to increase the background space for any content to be displayed inside a box.
padding: 10px; => Padding in all directions.
padding-top/right/bottom/left: 10px; => specific

Shorthand syntax for padding: 
  If(only 3 values) then right=left;
  If(only 2 values) then right=left && top=bottom.

Margin -> Place outside the box/border. To manage spacing/positioning with other external html elements. 
margin: 10px;
margin-top/right/bottom/left. Also shorthand works here to like padding. 
margin: 0px auto; => center the elements with respect to the outer box. 

imp: horizontal margins & paddings between two external html elements add up. For vertical => top & bottom margins will collapse, while, top & bottom paddings don't. 
Collapse => final-margin = max(marginA,marginB).

min-height/width & max-height/width

an HTML elements size = summation of size of all paramters except the margins ie. paddings, content, border-thickness etc. And not just the content area.

overflow -> set on the parent's element to instruct browser on how to render child elements if size overexeceeds it's parent's dimensions.

visibility -> hidden, visible, collapse. If hidden, the void/structure/space of that html element would still persist but content would be hidden. 
However, If {display:none;} then whole element is removed.

Resetting Defaults - Sometimes, browser have default paddings/margins. This can confuse the developer, hence make everything to default - 
//code
*{
  margin: 0px;
  padding: 0px;
  box-sizing: border-box; //This is the best practice. With this - The height & width that we enter will not be specifically of content area, instead will incoperate the whole box size. 
 }



Lesson #4 - Display & Positioning

position keywords -> static, relative, fixed, absolute, sticky
offset keywords -> top, right, bottom, left {They have away nature, which means if top:20px => the element will be offsetted by 20px away from left}

KIMs: {Keep in mind points ;)}
1. Static & relative keep the element in the document flow. Hence when we scroll through the document flow, it'll also scroll. 
2. absolute & fixed positioning remove the element from document flow and then paste it at the desired position. Absolute though still scrolls with the document flow however fixed doesn't.
3. Static & relative would leave gap from where it's positioned. Means if it's relative to top: 100px => it'll move down 100px would leave it's void where it's static position was held and no other element {unless manually positioned} would take up it's place.
4. Fixed & Absolute don't leave gap/void in place of it's static orignal position. 
5. Fixed positioning is always with reference to the view port. 
6. Absolute positioning is always with reference to the last/nearest positioned ancestor in the html tree model {parent-child relationship}. If none found, it'll be positioned with reference to the view port/document window object.
7. Sticky positioning - Behaviour changes with scrolling. Unless crossed or it's orignal position is held in the view port, it'll stay intact. When scrolled over, it'll become fixed. Scrolling behavior goes contrary with the offset applied. Eg. If top: 20px, then when scrolling bottom, it'll get fixed at 20px with reference to view port. eg. if bottom: 20px, then => when scrolling up => offset will be 20px from bottom of view port (in the away direction.) 

z-index: accepts integer values. Decides who overlaps the other in case of positioning overlapping.

Display: 
1. inline: don't require new line, occupy space only enough to fit content, dimensions of content area cannot be altered, displays every content in same line from left to right order as in the html document file.
2. block: require new line, by default occupy full width of parent element and height enough to occupy content, dimensions can be altered via box model paramters, displays every new block in new line, in top to bottom order as in the html document file.
3. inline-block: like inline, but blocks. advantage => dimensions can be altered using height & width attributes.

